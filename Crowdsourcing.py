# -*- coding: utf-8 -*-
"""homework7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y4bsXdLs6TCtQdB-TzG-4zxTDG5aO_Dm
"""

############################################################
# NETS 213: Homework 7
############################################################

import pandas as pd

# Part 1 - Majority vote

def majority_vote(mturk_res):
    labels = dict()

    for index, row in mturk_res.iterrows(): # put every attr-adj pairing in dictionary with labels
      id = row['Input.attr_id']
      for i in range(1, 11):
        adj_i = row['Input.adj_' + str(i)]
        answer_i = row['Answer.adj_' + str(i)]
        tup = (id, adj_i)

        if tup not in labels: # put in dictionary
          labels[tup] = 0

        if answer_i == "Yes" or answer_i == "yes":
          labels[tup] += 1
        elif answer_i == "No" or "Naa": # meaning tup is not in labels
          labels[tup] -= 1
        # ignore blanks

    result = []
    # make the result list of tuples
    for tup in labels:
      if labels[tup] > 0: # if positive, majority is Yes
        new_tup = (tup[0], tup[1], True)
        result.append(new_tup)
      else: # if negative, majority is No
        new_tup = (tup[0], tup[1], False)
        result.append(new_tup)

    result = sorted(result, key=lambda tup: (tup[0], tup[1])) 
    return result

def majority_vote_workers(mturk_res, votes):
    result = []
    qualities = {} 
    num_tasks_done = {} # key worker, value num_tasks done
    for index, row in mturk_res.iterrows():
      workerID = row['WorkerId']

      if workerID not in qualities: # put worker in dictionaries
        qualities[workerID] = 0
      if workerID not in num_tasks_done:
        num_tasks_done[workerID] = 0

      for i in range(1, 11):
        id = row['Input.attr_id']
        adj_i = row['Input.adj_' + str(i)]
        answer_i = row['Answer.adj_' + str(i)]

        if answer_i == "Yes" or answer_i == "yes": # convert to boolean
          answer_i = True
        elif answer_i == "No" or answer_i == "Naa":
          answer_i = False
        # ignore Nan

        for tup in votes: # update dictionaries
          if tup[0] == id and tup[1] == adj_i:
            if tup[2] == answer_i: # check if in majority
              qualities[workerID] += 1
            num_tasks_done[workerID] += 1 # always increment
            break 

    for worker in qualities:   # average out workers' score and put in list
      qualities[worker] /= num_tasks_done[worker]
      tup = (worker, round(qualities[worker], 3))
      result.append(tup)

    result = sorted(result, key=lambda tup: tup[0]) # sort by workerId
    return result

# Part 1 - Weighted majority vote

def weighted_majority_vote_workers(mturk_res):
    result = []
    qualities = {}
    gold_pairs = {} # key worker, value num times done

    for index, row in mturk_res.iterrows():
      workerID = row['WorkerId']

      if workerID not in qualities: # put worker in dictionaries
        qualities[workerID] = 0
      if workerID not in gold_pairs:
        gold_pairs[workerID] = 0
      
      for i in range(1, 6): # positive quality controls (5)
        answer_i = row['Answer.pos_qual_ctrl_' + str(i)]
        if answer_i == "Yes" or answer_i == "yes":
          qualities[workerID] += 1
          gold_pairs[workerID] += 1 
        elif answer_i == "No" or answer_i == "Naa": # ignore blank answers
          gold_pairs[workerID] += 1 

      answer_neg = row['Answer.neg_qual_ctrl'] # negative qual control (1)
      if answer_neg == "No" or answer_neg == "Naa":
        qualities[workerID] += 1
        gold_pairs[workerID] += 1
      elif answer_neg == "Yes" or answer_neg == "yes":
        gold_pairs[workerID] += 1
      # ignore nan

    for worker in qualities:   # average out workers' score and put in list
      qualities[worker] /= gold_pairs[worker]
      tup = (worker, round(qualities[worker], 3))
      result.append(tup)
    
    result = sorted(result, key=lambda tup: tup[0]) # sort by workerId
    return result
    
def weighted_majority_vote(mturk_res, workers):
    labels = dict() # maps attr-adj tuple to [num_true, num_false]

    for index, row in mturk_res.iterrows(): # put every attr-adj pairing in dict with labels
      id = row['Input.attr_id']
      worker_id = row['WorkerId']
      for i in range(1, 11):
        adj_i = row['Input.adj_' + str(i)]
        answer_i = row['Answer.adj_' + str(i)]
        tup = (id, adj_i)

        if tup not in labels: # put in dictionary
          labels[tup] = [0, 0] # index 0 is True and index 1 is False

        if answer_i == "Yes" or answer_i == "yes":
          num_list = labels[tup]
          for new_tup in workers:
            if new_tup[0] == worker_id:
              num_list[0] += new_tup[1] # tup[1] is the worker quality
              labels[tup] = num_list # update dictionary
              break
        elif answer_i == "No" or answer_i == "Naa": # meaning answer is No or Naa
          num_list = labels[tup]
          for new_tup in workers:
            if new_tup[0] == worker_id:
              num_list[1] += new_tup[1]
              labels[tup] = num_list
              break
        # note, there could be nan
        
    result = []
    # make the result list of tuples
    for tup in labels:
      num_Trues = labels[tup][0]
      num_Falses = labels[tup][1]
      if num_Trues > num_Falses: # if majority is Yes
        new_tup = (tup[0], tup[1], True)
        result.append(new_tup)
      else: # majority is No
        new_tup = (tup[0], tup[1], False)
        result.append(new_tup)

    result = sorted(result, key=lambda tup: (tup[0], tup[1]))
    return result

# Part 2 - EM algorithm

def em_worker_quality(rows, labels):
    workers_qual = {}
    workers = set()
    for row in rows: # set up labels dictionary. keys are worker/website. Value is boolean
      worker = row[0]
      worker_num = int(worker[len(worker) - 1]) - 1 # -1 for indexing
      website = row[1]
      label = row[2]
      workers.add(worker_num)

      tup = (worker_num, website)
      if label == "porn":
        workers_qual[tup] = True
      else:
        workers_qual[tup] = False

    matrix = {} # maps worker to 2D matrix
    for worker in workers: # go through worker matrices
      if worker not in matrix:
        matrix[worker] = [[0, 0], [0, 0]]
      
      for pair in workers_qual: 
        if pair[0] == worker: # go through worker's column
          curr_web = pair[1]
          worker_ans = workers_qual[pair]
          if labels[curr_web][0] == 1 and worker_ans: # is porn, guessed right
            matrix[worker][0][0] += 1
          elif labels[curr_web][0] == 1 and not worker_ans: # is porn, guessed wrong
            matrix[worker][0][1] += 1
          elif labels[curr_web][0] == 0 and worker_ans: # not porn, guessed wrong
            matrix[worker][1][0] += 1
          elif labels[curr_web][0] == 0 and not worker_ans: # not porn, guessed right
            matrix[worker][1][1] += 1

      # normalize
      sum_row = sum(matrix[worker][0]) # change first row
      matrix[worker][0] = [round(matrix[worker][0][0] / sum_row, 2), 
                           round(matrix[worker][0][1] / sum_row, 2)]
      sum_row = sum(matrix[worker][1]) # change second row
      matrix[worker][1] = [round(matrix[worker][1][0] / sum_row, 2), 
                           round(matrix[worker][1][1] / sum_row, 2)]
    return matrix

def em_votes(rows, worker_qual):
    labels = {}
    websites = set()
    for row in rows: # set up dictionary. keys are worker/website. Value is boolean
      worker = row[0]
      worker_num = int(worker[len(worker) - 1])
      website = row[1]
      label = row[2]
      websites.add(website)

      tup = (worker_num - 1, website)
      if label == "porn":
        labels[tup] = True
      else:
        labels[tup] = False

    table_labels = {} # key is website. Value is array. index 0 is True, index 1 is false
    for site in websites: # put stuff in table 
      if site not in table_labels:
        table_labels[site] = [0, 0]
      
      for worker in range(len(worker_qual)):
        key = (worker, site)
        value = labels[key] # value is person's thought on website
        if value:
          table_labels[site][0] += worker_qual[worker][0][0]
          table_labels[site][1] += worker_qual[worker][1][0] # Add to Not porn
        else:
          table_labels[site][0] += worker_qual[worker][0][1]
          table_labels[site][1] += worker_qual[worker][1][1] # Add to not porn

    for site in table_labels: # change to 0s and 1s
      if table_labels[site][0] > table_labels[site][1]:
        table_labels[site][0] = 1
        table_labels[site][1] = 0
      else:
        table_labels[site][0] = 0
        table_labels[site][1] = 1
    return table_labels
        

def em_iteration(rows, worker_qual):
    labels = em_votes(rows, worker_qual)
    worker_qual = em_worker_quality(rows, labels)
    return labels, worker_qual

def em_vote(rows, iter_num):
    iden_matrix = [[1, 0], [0, 1]]
    curr_qual = [] # index 0 refers to worker 1, index 4 refers to worker 5 etc. 
    for i in range(5):
      curr_qual.append(iden_matrix)

    labels = {}
    while iter_num > 0:
      new_result = em_iteration(rows, curr_qual)
      curr_qual = new_result[1]
      labels = new_result[0]
      iter_num -= 1
    
    result = []
    for website in labels:
      if labels[website][0] > labels[website][1]: # if true, is porn
        tup = (website, 'porn')
        result.append(tup)
      else:
        tup = (website, 'notporn')
        result.append(tup)
    result = sorted(result, key=lambda tup: tup[0])
    return result
# Part 3 - Qualified workers

def select_qualified_worker(mturk_res):
    results = dict()
    result_list = []
    debug = []
    for index, row in mturk_res.iterrows():
      worker_id = row['WorkerId']

      if worker_id not in results:
        results[worker_id] = [0, 1]
      else:
        results[worker_id][1] += 1 
      if row['Answer.neg_qual_ctrl'] == "No" or row['Answer.neg_qual_ctrl'] == "Naa":
        percentage = 0.0;
        for i in range (1,6):
          if row['Answer.pos_qual_ctrl_' + str(i)] == "Yes":
            percentage += 1/5
        if percentage >= 4/5:
          results[worker_id][0] += 1
         
    for key in results:
      if results[key][1] >= 5:
        result_list.append((key, round(results[key][0]/results[key][1], 3)))

    result_list = [tup for tup in result_list if tup[1] >= 0.75]
    result_list = sorted(result_list, key=lambda tup: tup[0]) # sort by workerId

    return result_list


# Your main function

def main():
    # Read in CVS result file with pandas
    # PLEASE DO NOT CHANGE
    mturk_res = pd.read_csv('hw7_data.csv')

    #Call functions and output required CSV files
    list1 = majority_vote(mturk_res)
    df1 = pd.DataFrame(list1)
    df1.columns = ['attr_id', 'adj', 'label']
    df1.to_csv('output1.csv', index=False)

    list2 = majority_vote_workers(mturk_res, list1)
    df2 = pd.DataFrame(list2)
    df2.columns = ['worker_id', 'quality']
    df2.to_csv('output2.csv', index=False)

    list3 = weighted_majority_vote_workers(mturk_res)
    df3 = pd.DataFrame(list3)
    df3.columns = ['worker_id', 'quality']
    df3.to_csv('output3.csv', index=False)

    list4 = weighted_majority_vote(mturk_res, list3)
    df4 = pd.DataFrame(list4)
    df4.columns = ['attr_id', 'adj', 'label']
    df4.to_csv('output4.csv', index=False)

    rows = []
    with open('em_toy_data.txt') as f:
      rows = f.readlines()
      rows = [x.strip() for x in rows]
      rows = [x.split('\t') for x in rows]
    f.close()

    list5 = em_vote(rows, 3)
    df5 = pd.DataFrame(list5)
    df5.columns = ['url', 'label']
    df5.to_csv('output5.csv', index=False)

    list6 = select_qualified_worker(mturk_res)
    df6 = pd.DataFrame(list6)
    df6.columns = ['worker_id', 'percentage']
    df6.to_csv('output6.csv', index=False)


if __name__ == '__main__':
    main()